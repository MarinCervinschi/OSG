{
	//Using snippet-generator.app
	//Davide Mecugni
	"prima riga": {
		"prefix": "prima",
		"body": [
			"//Using C17",
			"//Davide Mecugni",
			"//File ${TM_FILENAME}",
			"$1"
		]
	},
	"main": {
		"prefix": "main",
		"body": [
			"int main(int argc, char* argv[]) {",
			"    $1",
			"    exit(0);",
			"}"
		]
	},
	"librerie": {
		"prefix": "lib",
		"body": [
			"#include <stdio.h> //Standard I/O: printf, BUFSIZ",
			"#include <fcntl.h> //File CoNTrol: open, O_RDONLY, O_WRONLY, O_RDWR, O_CREAT(crea se non esiste), O_APPEND(solo R o RW), O_TRUNC(distrugge contenuto se esiste, O_EXCL(fallisce se il file esiste gia')",
			"#include <stdlib.h> //STanDard LIBrary: exit, malloc, calloc, free, atoi",
			"#include <unistd.h> //UNIx Standard: read, write, close, SEEK_SET, SEEK_CUR, SEEK_END",
			"#include <string.h> //STRING: strlen, strcpy, strcat",
			"#include <sys/stat.h> //SYStem STATus: stat, fstat, S_IFMT, S_IFDIR, S_IFREG",
			"#include <sys/wait.h> //SYStem WAIT: wait",
			"#include <errno.h> //ERror NUmber: errno",
			"$1"
		]
	},
	"copia file": {
		"prefix": "copiafile",
		"body": [
			"//CONTROLLA I CODICI DI ERRORE",
			"int copyfile (char *f1, char * f2) {",
			"    int infile, outfile, nread;",
			"    char buffer [BUFSIZ]; // Usato per i caratteri",
			"    if (( infile = open (f1, O_RDONLY)) < 0 ){",
			"        //Errore nell'apertura in lettura del primo file",
			"        return 1;",
			"    }",
			"    if (( outfile = creat (f2, ${1:permission})) <0 ) {",
			"        //Errore nella creazione del secondo file",
			"        close (infile);", 
			"        return 2;",
			"    }",
			"    while (( nread = read (infile, buffer, BUFSIZ)) > 0 ) {",
			"        if ( write (outfile , buffer, nread ) < nread ) {",
			"            //Errore nella scrittura del file",
			"            close (infile);", 
			"            close (outfile);",
			"        return 3;",
			"        }",
			"    }",
			"    close (infile);",
			"    close (outfile);",
			"    //File copiato correttamente",
			"    return 0;",
			"}"
		],
		"description": "Copies a file"
	},
	"pappagallo": {
        "prefix": "pappagallo",
        "body": [
            "char buffer [BUFSIZ];",
            "int nread;",
            "while ( (nread = read (0, buffer, BUFSIZ)) > 0 ) {",
            "    /* lettura dallo standard input fino a che ci sono caratteri */",
            "    write (1 , buffer, nread);",
            "    /* scrittura sullo standard output dei caratteri letti */",
            "}"
        ],
        "description": "Reads from standard input and writes to standard output"
    },
	"Appendi file": {
		"prefix": "appendifilestdin",
		"body": [
			"//CONTROLLA I CODICI DI ERRORE",
			"int appendfile (char *f1)",
			"{ int outfile, nread; char buffer [BUFSIZ];",
			"    if ( (outfile = open ( f1, O_WRONLY)) < 0 )",
			"    /* apertura in scrittura */",
			"    { ",
			"        if (( outfile = creat ( f1, PERM)) <0 )",
			"        /* se il file non esiste, viene creato */",
			"            return (-1); }",
			"        else ",
			"        /* se il file esiste, ci si posiziona alla fine */",
			"            lseek (outfile, 0L, 2);",
			"        ",
			"    while (( nread = read (0, buffer, BUFSIZ)) > 0 ) /* si legge dallo standard input */",
			"    {   ",
			"        if ( write (outfile, buffer, nread ) < nread )",
			"        { ",
			"            close (outfile); ",
			"            return (-2); /* errore */ }",
			"    }",
			"    /* fine del file di input */",
			"    close (outfile); ",
			"    return (0);",
			"}"
		],
		"description": "Appendi file"
	},
	"Muovi file": {
	"prefix": "movefile",
	"body": [
		"//CONTROLLA CODICE DI RITORNO",
		"int mv(char *file1, char *file2)",
		"{ ",
		"    /* controllo del numero di parametri */",
		"    if (link(file1, file2) < 0)",
		"    { ",
		"        printf (\"Errore\\n\"); ",
		"        return 1;",
		"    }",
		"    /* controllo sulla operazione di link */",
		"    if (unlink(file1) < 0)",
		"    { ",
		"        printf (\"Errore\\n\"); ",
		"        return 2;",
		"    }",
		"    /* controllo sulla operazione di unlink */",
		"    printf (\"Ok\\n\"); ",
		"    return 0;",
		"}"
	],
	"description": "Muovi file"
	},
	"file OK": {
	"prefix": "fileOK",
	"body": [
		"void fileOK(char* fileName)",
		"{",
		"    if (access(fileName, F_OK) == 0)",
		"        printf(\"OK file\\n\");",
		"    else ",
		"        printf(\"NO file\\n\");",
		"}"
	],
	"description": "file OK"
	},
	"diritti file": {
	"prefix": "fileDiritti",
	"body": [
		"void dirittiFile(char* fileName)",
		"{",
		"    if (access(fileName, F_OK) == 0)",
		"        printf(\"OK file\\n\");",
		"    else ",
		"        printf(\"NO file\\n\");",
		"    if (access(fileName, R_OK) == 0)",
		"        printf(\"OK lettura\\n\");",
		"    else ",
		"        printf(\"NO lettura\\n\");",
		"    if (access(fileName, W_OK) == 0)",
		"        printf(\"OK scrittura\\n\");",
		"    else ",
		"        printf(\"NO scrittura\\n\");",
		"    if (access(fileName, X_OK) == 0)",
		"        printf(\"OK esecuzione\\n\");",
		"    else ",
		"        printf(\"NO esecuzione\\n\");",
		"}"
	],
	"description": "diritti file"
	},
	"stat print": {
	"prefix": "statPrint",
	"body": [
		"void statPrint(char *file)",
		"{ ",
		"    struct stat b;",
		"    if (stat(file, &b) != 0)",
		"    { ",
		"        printf(\"NO!!!\\n\"); ",
		"        exit(-2); ",
		"    }",
		"    printf(\"st-dev=%ld\\n\", b.st_dev);",
		"    printf(\"st-ino=%ld\\n\", b.st_ino);",
		"    printf(\"st-mode=%ld\\n\", b.st_mode);",
		"    printf(\"st-nlink=%ld\\n\", b.st_nlink);",
		"    printf(\"st-uid=%ld\\n\", b.st_uid);",
		"    printf(\"st-gid=%ld\\n\", b.st_gid);",
		"    printf(\"st-rdev=%ld\\n\", b.st_rdev);",
		"    printf(\"st-size=%ld\\n\", b.st_size);",
		"    printf(\"st-atime=%ld\\n\", b.st_atime);",
		"    printf(\"st-mtime=%ld\\n\", b.st_mtime);",
		"    printf(\"st-ctime=%ld\\n\", b.st_ctime);",
		"}"
	],
	"description": "stat print"
	},
	"fstat print": {
	"prefix": "fstatPrint",
	"body": [
		"void fstatPrint(char *file)",
		"{ ",
		"    int fd; ",
		"    struct stat b;",
		"    //Per usare fstat bisogna aprire il file",
		"    if ((fd=open(file, 0)) <= 0)",
		"    { ",
		"    printf(\"NO OPEN!!!\\n\"); ",
		"    exit(-2);",
		"    }",
		"    //Se fstat non restituisce 0 c'e' stato un errore",
		"    if (fstat(fd, &b) != 0)",
		"    { ",
		"    printf(\"NO!!!\\n\"); ",
		"    exit(-3); ",
		"    }",
		"    printf(\"st-dev=%ld\\n\", b.st_dev);",
		"    printf(\"st-ino=%ld\\n\", b.st_ino);",
		"    printf(\"st-mode=%ld\\n\", b.st_mode);",
		"    printf(\"st-nlink=%ld\\n\", b.st_nlink);",
		"    printf(\"st-uid=%ld\\n\", b.st_uid);",
		"    printf(\"st-gid=%ld\\n\", b.st_gid);",
		"    printf(\"st-rdev=%ld\\n\", b.st_rdev);",
		"    printf(\"st-size=%ld\\n\", b.st_size);",
		"    printf(\"st-atime=%ld\\n\", b.st_atime);",
		"    printf(\"st-mtime=%ld\\n\", b.st_mtime);",
		"    printf(\"st-ctime=%ld\\n\", b.st_ctime);",
		"}"
	],
	"description": "fstat print"
	},
	"controllo file": {
	"prefix": "controlloFile",
	"body": [
		"//Controllo se e' un file",
		"if( open(${1:stringa}, O_RDONLY) < 0){",
		"    printf(\"Errore: il parametro %s non e' un file\\n\", ${1:stringa});",
		"    exit(${2:EXITCODE});",
		"}"
	],
	"description": "controllo file"
	},
	"controllo numero": {
	"prefix": "controlloNumero",
	"body": [
		"//Controllo se e' un numero",
		"int n = atoi(${1:stringa});",
		"if(n <= 0){",
		"    printf(\"Errore: il parametro %s non e' un numero positivo\\n\", ${1:stringa});",
		"    exit(${2:EXITCODE});",
		"}"
	],
	"description": "controllo numero"
	},
	"Controllo numero con sscanf": {
	"prefix": "controlloNumeroSscanf",
	"body": [
		"int n;",
		"//Controllo che e' un numero con sscanf",
		"if (sscanf(${1:PARAMETRO}, \"%d\", &n) != 1) {",
		"    printf(\"Errore, il parametro %s passato non e' un numero\", ${1:PARAMETRO});",
		"    exit(${2:EXICODE});",
		"} ",
		"  "
	],
	"description": "Controllo numero con sscanf"
	},
	"controllo carattere": {
	"prefix": "controlloCarattere",
	"body": [
		"//Controllo se e' un carattere",
		"//ARRAY DI CARATTERI",
		"if(${1:stringa}[1] != '\\0'){",
		"    printf(\"Errore: il parametro %s non e' un carattere\\n\", ${1:stringa});",
		"    exit(${2:EXITCODE});",
		"}"
	],
	"description": "controllo carattere"
	},
	"controllo numero di parametri": {
	"prefix": "controlloParametri",
	"body": [
		"//Controllo esatto parametri",
		"if(argc != ${1:parametri+1}){",
		"    printf(\"Errore: inserire esattamente  ${2:PARAMETRI} parametri\\n\");",
		"    exit(${3:EXITCODE});",
		"}"
	],
	"description": "controllo numero di parametri"
	},
	"conta numero di caratteri uguali a Cx in file": {
	"prefix": "contaCharUgualiACx",
	"body": [
		"//Ritorna il numero di occorrenze del carattere Cx nel file F",
		"long int contaOccorrenzeCarattere(const char *F, char Cx){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    char buffer;",
		"    long int occorrenze = 0;",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"        if(buffer == Cx){",
		"            occorrenze++;",
		"        }",
		"    }",
		"    printf(\"Il carattere %c compare %ld volte nel file %s\\n\", Cx, occorrenze, F);",
		"    close(fd);",
		"    return occorrenze;",
		"}"
	],
	"description": "conta numero di caratteri uguali  a Cx in file"
	},
	"conta occorrenze di caratteri uguali  a Cx in file": {
	"prefix": "contaOccorrenzeCharUgualiACx",
	"body": [
		"//Ritorna il numero di occorrenze del carattere Cx nel file F",
		"long int contaOccorrenzeCarattere(const char *F, char Cx){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    char buffer;",
		"    long int occorrenze = 0;",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"        if(buffer == Cx){",
		"            occorrenze++;",
		"        }",
		"    }",
		"    printf(\"Il carattere %c compare %ld volte nel file %s\\n\", Cx, occorrenze, F);",
		"    close(fd);",
		"    return occorrenze;",
		"}"
	],
	"description": "conta numero di caratteri uguali  a Cx in file"
	},
	"Cat": {
	"prefix": "cat",
	"body": [
		"//Se file non esiste, usa lo standard input",
		"void myCat(char* file)",
		"{       ",
		"    int nread;                      // valore ritorno read ",
		"    char buffer[BUFSIZ];            // usato per i caratteri ",
		"    int fd = 0;                     // usato per la open; N.B. se non viene passato alcun parametro allora rimarra' uguale a 0, quindi identifichera' lo STANDARD INPUT ",
		"",
		"    if ((fd = open(file, O_RDONLY)) < 0)// ERRORE se non si riesce ad aprire in LETTURA il file ",
		"    {       printf(\"Errore in apertura file %s dato che fd = %d\\n\", file, fd);",
		"            exit(${1:EXITCODE}); ",
		"    }",
		"",
		"    while ((nread = read(fd, buffer, BUFSIZ)) > 0 ){",
		"        // scrittura sullo standard output dei caratteri letti ",
		"        write(1, buffer, nread);",
		"    }",
		"    if(fd != 0){",
		"        close(fd);",
		"    }",
		"}"
	],
	"description": "Cat"
	},
	"Lunghezza file con open": {
	"prefix": "fileLunghezzaConOpen",
	"body": [
		"long lunghezzaFileConOpen(const char* file){",
		"    int fd = open(file, O_RDONLY);",
		"    long lenght = lseek(fd, 0, SEEK_END);",
		"    close(fd);",
		"    return lenght;",
		"}"
	],
	"description": "Lunghezza file con open"
	},
	"Stampa l'n-esimo carattere in un file con read": {
	"prefix": "stampaNEsimoCarattereInFileConRead",
	"body": [
		"//Stampa l'n-esimo carattere nel file fornito",
		"void stampaNEsimoCarattereInFileConRead(const char *F, int n){",
		"    //Apertura file",
		"    int fd, num;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(4);",
		"    }",
		"    char *buffer = malloc(sizeof(char) * n);",
		"    if(buffer == NULL){",
		"        printf(\"Impossibile allocare dinamicamente la memoria\\n\");",
		"        exit(5);",
		"    }",
		"    //Lettura file carattere per carattere",
		"    while((num = read(fd, buffer, n)) > 0){",
		"        printf(\"Il carattere multiplo %d-esimo all'interno del file %s e' %c\\n\", n,F,buffer[num-1]);",
		"    }",
		"    close(fd);",
		"    free(buffer);",
		"}"
	],
	"description": "Stampa l'n-esimo carattere in un file con read"
	},
	"Stampa l'n-esimo carattere in un file con lseek": {
	"prefix": "stampaNEsimoCarattereInFileConlseek",
	"body": [
		"void stampaNEsimoCarattereInFileConlseek(const char* F, int n){",
		"    int fd;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(4);",
		"    }",
		"    long lunghezzaF = lseek(fd, 0, SEEK_END);",
		"    char c;",
		"    for(long i=n-1;i-1<lunghezzaF;i+=n){",
		"        lseek(fd, (int)i, SEEK_SET);",
		"        if(read(fd, &c, 1) == -1){",
		"            printf(\"Errore durante la lettura del file\\n\");",
		"            exit(5);",
		"        }",
		"        printf(\"Il carattere multiplo %d-esimo all'interno del file %s e' %c\\n\", n,F,c);",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "Stampa l'n-esimo carattere in un file con lseek"
	},
	"file char per char": {
	"prefix": "fileCharPerChar",
	"body": [
		"// File char per char",
		"void fileCharPerChar(const char *F){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    char buffer;",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "file char per char"
	},
	"file sostituisci carattere con lo spazio": {
	"prefix": "fileSostituisciCarattere",
	"body": [
		"// Apertura file RW e sostituzione del carattere Cx con lo spazio",
		"void fileSostituisciCarattere(const char *F, char Cx){",
		"    //Apertura file",
		"    int fd, n;",
		"    if((fd = open(F, O_RDWR)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", F);",
		"        exit(4);",
		"    }",
		"    char buffer;",
		"    const char spazio = ' ';",
		"    //Lettura file carattere per carattere",
		"    while((n = read(fd, &buffer, 1)) > 0){",
		"        if(buffer == Cx){",
		"            lseek(fd, -1, SEEK_CUR);",
		"            write(fd, &spazio, 1);",
		"        }",
		"    }",
		"    close(fd);",
		"}"
	],
	"description": "file sostituisci carattere con lo spazio"
	},
	"file In stampato a file Out": {
	"prefix": "fileMyHead",
	"body": [
		"// f char per char finche' non si trovano n /n",
		"void myhead(const char* f, int num){",
		"    char buffer;",
		"    int contaACapo = 0, n, fd;",
		"    //Se il file e' null leggo da STDIN",
		"    if(f == NULL){",
		"        fd = STDIN_FILENO;",
		"    }",
		"    else{",
		"        if((fd = open(f, O_RDONLY)) < 0){",
		"            printf(\"Errore: impossibile aprire il file %s\\n\", f);",
		"            exit(${1:EXITCODE});",
		"        }",
		"    }",
		"    //Leggo e mi fermo quando gli a capo sono == num",
		"    while(((n = read(fd, &buffer, 1)) > 0) && contaACapo < num){",
		"        if(buffer == '\\n'){",
		"            contaACapo++;",
		"        }",
		"        write(STDOUT_FILENO, &buffer, 1);",
		"    }",
		"}"
	],
	"description": "file In stampato a file Out"
	},
	"n esima riga di un file": {
	"prefix": "fileNesimaRiga",
	"body": [
		"// f char per char finche' non si trova l'n-esima riga",
		"//ATTENZIONE: il buffer deve essere abbastanza grosso",
		"int nEsimaRiga(const char* f, int num, char *buffer){",
		"    int contaACapo = 0, fd;",
		"   ",
		"    if((fd = open(f, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", f);",
		"        exit(${1:EXITCODE});",
		"    }",
		"    }",
		"    int j=0;",
		"",
		"    while ((read(fd, &(buffer[j]), 1) != 0) && contaACapo < num){",
		"        if(buffer[j] == '\\n'){",
		"            contaACapo++;",
		"            buffer[j] = '\\0';",
		"            j = 0;",
		"            continue;",
		"        }",
		"        ++j;",
		"    }",
		"    ",
		"    return contaACapo == num;",
		"}"
	],
	"description": "n esima riga di un file"
	},
	"righe lunghe n caratteri": {
	"prefix": "fileRigheLungheN",
	"body": [
		"// f char per char finche' non si trova l'n-esima riga",
		"//ATTENZIONE: il buffer deve essere abbastanza grosso",
		"void righeLungheN(const char* f, int num){",
		"    char buffer[256];",
		"    int fd;",
		"    if((fd = open(f, O_RDONLY)) < 0){",
		"        printf(\"Errore: impossibile aprire il file %s\\n\", f);",
		"        exit(${1:EXITCODE});",
		"    }",
		"",
		"    int j=0;",
		"    int righeTrovate = 1;",
		"    while ((read(fd, &(buffer[j]), 1) != 0) && j<255){",
		"        if(buffer[j] == '\\n'){",
		"            buffer[j] = '\\n';",
		"            buffer[j+1] = '\\0';",
		"            if(j + 1 == num){",
		"                printf(\"Trovata %d-esima riga: %s\", righeTrovate, buffer);",
		"                righeTrovate++;",
		"            }",
		"            j = 0;",
		"            continue;",
		"        }",
		"        ++j;",
		"    }",
		"}"
	],
	"description": "righe lunghe n caratteri"
	},
	"generazione numero random": {
		"prefix": "random",
		"body": [
		  "#include <time.h>",
		  "//DA AGGIUNGERE NEL MAIN",
		  "//srand(time(NULL));",
		  "//PER OTTENERE RANDOM",
		  "//int r = rand();"
		],
		"description": "generazione numero random"
	},
	"gestione completa figlio": {
		"prefix": "figlio",
		"body": [
			"int pid, pidFiglio; /* pid per fork e pidFiglio per wait */",
			"int pidPadre = getpid();",
			"printf(\"La pid del padre e' :%d\\n\", pidPadre);",
			"if ((pid = fork()) < 0)",
			"{",
			"    //Fork fallita",
			"    printf(\"Errore in fork\\n\");",
			"    exit(${1:EXITCODE});",
			"}",
			"",
			"if (pid == 0)",
			"{ ",
			"    /* CODICE DEL FIGLIO*/",
			"",
			"",
			"    exit(CODICEDUSCITA);",
			"    /*FINE CODICE DEL FIGLIO*/",
			"}",
			"",
			"/* padre */",
			"printf(\"Generato figlio con PID = %d\\n\", pid);",
			"// Il padre aspetta il figlio salvando lo status",
			"int status;",
			"if ((pidFiglio=wait(&status)) < 0)",
			"{",
			"    //La wait non ha avuto successo",
			"    printf(\"Errore in wait\\n\");",
			"    exit(${2:EXITCODE});",
			"}",
			"//Se il pid ritornato dalla wait e' corretto",
			"if (pid == pidFiglio){",
			"    printf(\"Terminato figlio con PID = %d\\n\", pidFiglio);",
			"    if (WIFEXITED(status)) {",
			"        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
			"        printf(\"Il figlio e' ritornato con codice: %d\\n\", WEXITSTATUS(status));",
			"    } else {",
			"        //Lo status riporta una terminazione anomala",
			"        printf(\"Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}",
			"else ",
			"{       ",
			"    //Il pid non corrisponde con il figlio aspettato",
			"    printf(\"Il pid della wait non corrisponde al pid della fork!\\n\");",
			"    exit(${3:EXITCODE});",
			"}"
		],
		"description": "gestione completa figlio"
	},
	"leggi numero in input ": {
	"prefix": "inputNumero",
	"body": [
		"int ${1:NUMEROLETTO};",
		"printf(\"Inserire numero\\n\");",
		"if( scanf(\"%d\",&${1:NUMEROLETTO}) != 1){",
		"    printf(\"Numero non letto correttamente!\\n\");",
		"}"
	],
	"description": "leggi numero in input "
	},
	"creazione multipli figli N": {
		"prefix": "figliNSenzaPID",
		"body": [
			"pid_t pid;",
			"pid_t pidPadre = getpid();",
			"int N = ${1:FIGLI}",
			"printf(\"La pid del padre e' :%d\\n\", pidPadre);",
			"printf(\"Il padre deve generare %d figli\\n\", N);",
			"",
			"// Per la creazione di N figli",
			"for(int i=0; i < N; i++){",
			"    if ((pid = fork()) < 0)",
			"    {",
			"        //Fork fallita",
			"        printf(\"Errore in fork\\n\");",
			"        exit(${2:ERRORE});",
			"    }",
			"    ",
			"    if (pid == 0)",
			"    { ",
			"        /* CODICE DEL FIGLIO*/",
			"",
			"        printf(\"Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"        exit(i);",
			"",
			"        /*FINE CODICE DEL FIGLIO*/",
			"    }",
			"    printf(\"Generato figlio con PID = %d\\n\", pid);",
			"}",
			"",
			"/* padre */",
			"pid_t pidFiglio;",
			"int status, ritorno;",
			"// Il padre aspetta i figli salvando lo status",
			"for(int i=0; i<N;i++){",
			"    if ((pidFiglio=wait(&status)) < 0)",
			"    {",
			"        //La wait non ha avuto successo",
			"        printf(\"Errore in wait\\n\");",
			"        exit(${3:ERRORE});",
			"    }",
			"",
			"    printf(\"Terminato figlio con PID = %d\\n\", pidFiglio);",
			"    if (WIFEXITED(status)) {",
			"        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
			"        ritorno = WEXITSTATUS(status);",
			"        printf(\"Il figlio e' ritornato con codice: %d\\n\", ritorno);",
			"    } else {",
			"        //Lo status riporta una terminazione anomala",
			"        printf(\"Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}"
		],
		"description": "creazione multipli figli N"
	},
	"creazione multipli figli N con salvataggio PID": {
		"prefix": "figliNConSalvataggioPID",
		"body": [
			"int N = ${1:NUMEROFIGLI}",
			"printf(\"La pid del padre e' :%d\\n\", pidPadre);",
			"printf(\"Il padre deve generare %d figli\\n\", N);",
			"",
			"pid_t *pidDeiFigli = malloc(N*sizeof(pid_t));",
			"",
			"if(pidDeiFigli == NULL){",
			"    printf(\"Errore nell'allocazione della memoria\\n\");",
			"    exit(${2:ERRORE});",
			"}",
			"",
			"// Per la creazione di N figli",
			"for(int i=0; i < N; i++){",
			"    if ((pid = fork()) < 0)",
			"    {",
			"        //Fork fallita",
			"        printf(\"Errore in fork\\n\");",
			"        free(pidDeiFigli);",
			"        exit(${3:ERRORE});",
			"    }",
			"    ",
			"    if (pid == 0)",
			"    { ",
			"        /* CODICE DEL FIGLIO*/",
			"",
			"        printf(\"Figlio, pid: %d, indice %d\\n\", getpid(), i);",
			"        exit(EXITCODEFIGLIO);",
			"",
			"        /*FINE CODICE DEL FIGLIO*/",
			"    }",
			"    printf(\"Generato figlio con PID = %d\\n\", pid);",
			"    pidDeiFigli[i] = pid;",
			"}",
			"",
			"/* padre */",
			"pid_t pidFiglio;",
			"int status, ritorno;",
			"// Il padre aspetta i figli salvando lo status",
			"for(int i=0; i<N;i++){",
			"    if ((pidFiglio=wait(&status)) < 0)",
			"    {",
			"        //La wait non ha avuto successo",
			"        printf(\"Errore in wait\\n\");",
			"        free(pidDeiFigli);",
			"        exit(${4:ERRORE});",
			"    }",
			"",
			"    int posizione = 0;",
			"    for(int j=0; j<N; j++){",
			"        if(pidDeiFigli[j] == pidFiglio){",
			"            posizione = j;",
			"            break;",
			"        }",
			"    }",
			"    //Posizione partendo da 0",
			"    printf(\"Terminato figlio con PID = %d, creato per %d-esimo\\n\", pidFiglio, posizione);",
			"    if (WIFEXITED(status)) {",
			"        //Ricavo l'exitcode del figlio con la funzione WEXITSTATUS",
			"        ritorno = WEXITSTATUS(status);",
			"        printf(\"Il figlio e' ritornato con codice: %d\\n\", ritorno);",
			"    } else {",
			"        //Lo status riporta una terminazione anomala",
			"        printf(\"Il figlio e' terminato in modo anomalo\\n\");",
			"    }",
			"}",
			"//Libero la memoria dove ho salvato i PID dei figli",
			"free(pidDeiFigli);"
		],
		"description": "creazione multipli figli N con salvataggio PID"
	},
	"creaFileEsisteNonEsiste": {
		"prefix": "creaFileEsisteNonEsiste",
		"body": [
		  "//Controllo se un file esiste, se non esiste lo creo in scrittura",
		  "if((fd = open (\"${1:FILENAME}\", O_CREAT | O_EXCL | O_WRONLY, ${2:PERMESSI})) < 0 ){",
		  "    // Se il file esiste gia'",
		  "    printf(\"Il file ${1:FILENAME} esiste gia'\\n\");",
		  "}",
		  "",
		  "printf(\"Il file ${1:FILENAME} non esisteva: creato\\n\");",
		  "// Scrivo nel file"
		],
		"description": "creaFileEsisteNonEsiste"
	},
	"creaFileTroncando": {
		"prefix": "creaFileTroncando",
		"body": [
		  "// Controllo se un file esiste, se esiste lo tronco",
		  "if ( (fd= open (\"${1:FILENAME}\", O_TRUNC | O_WRONLY)) < 0 )",
		  "{",
		  "    printf(\"Il file ${1:FILENAME} non esiste\\n\");",
		  "    exit(${2:ERRORCODE});",
		  "    ",
		  "}",
		  "//Se il file esiste gia' lo abbiamo troncato",
		  "// Scrivo nel file"
		],
		"description": "creaFileTroncando"
	},
	"creaFileSenzaControllo": {
		"prefix": "creaFileSenzaControllo",
		"body": [
		  "// Apro il file in scrittura, se non esiste lo creo, se esiste puo' dare errori",
		  "if ( (fd = open (\"${1:FILENAME}\", O_CREAT | O_WRONLY, ${2:PERMESSI})) < 0 )",
		  "{ ",
		  "    printf(\"Errore in creazione file ${1:FILENAME}\\n\");",
		  "    exit(${3:ERRORCODE});",
		  "}",
		  "//Se siamo qui il file e' stato creato correttamente",
		  "printf(\"Creato il file ${1:FILENAME}\\n\");"
		],
		"description": "creaFileSenzaControllo"
	}
}